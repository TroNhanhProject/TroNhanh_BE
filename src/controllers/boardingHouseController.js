/**
 * T√™n file ƒë·ªÅ xu·∫•t: boardingHouseController.js
 * * Controller n√†y qu·∫£n l√Ω t·∫•t c·∫£ logic li√™n quan ƒë·∫øn Nh√† Tr·ªç (BoardingHouse) v√† c√°c th·ª±c th·ªÉ li√™n quan nh∆∞ Ph√≤ng (Room) v√† ƒê√°nh gi√° (Review).
 * - C√°c h√†m CRUD cho BoardingHouse.
 * - C√°c h√†m qu·∫£n l√Ω Review cho BoardingHouse.
 * - C√°c h√†m th·ªëng k√™ d√†nh cho ch·ªß tr·ªç (Owner).
 */

const BoardingHouse = require("../models/BoardingHouse");
const Room = require('../models/Room');
const Payment = require("../models/Payment");
const MembershipPackage = require("../models/MembershipPackage");
const Membership = require("../models/Membership")
const User = require('../models/User');
const Review = require('../models/Reviews');
const Booking = require('../models/Booking');
const mongoose = require('mongoose');
const path = require('path');
const fs = require('fs').promises; 

// ================================================================
// SECTION: QU·∫¢N L√ù NH√Ä TR·ªå (BOARDING HOUSE)
// ================================================================

/**
 * @description T·∫°o m·ªôt nh√† tr·ªç m·ªõi c√πng v·ªõi c√°c ph√≤ng c·ªßa n√≥.
 * @route POST /api/boarding-houses
 */

exports.createBoardingHouse = async (req, res) => {
    try {
        // Ph·∫ßn 1: Validation gi·ªØ nguy√™n...
        const { ownerId } = req.body;
        const latestPayment = await Payment.findOne({ ownerId, status: "Paid" })
            .sort({ createAt: -1 })
            .populate("membershipPackageId");

        // Ph·∫ßn 2: Th·ª±c thi ghi d·ªØ li·ªáu nh∆∞ng kh√¥ng d√πng transaction
        const { name, description, amenities } = req.body;
        const location = JSON.parse(req.body.location || "{}");
        const rooms = JSON.parse(req.body.rooms || "[]");
        const photoPaths = req.files?.map((file) => `/uploads/accommodation/${file.filename}`) || [];

        const newBoardingHouse = new BoardingHouse({
            ownerId, name, description, location, amenities, photos: photoPaths,
        });
        // B·ªè { session }
        const savedHouse = await newBoardingHouse.save();

        if (rooms && Array.isArray(rooms) && rooms.length > 0) {
            const roomDocs = rooms.map(room => ({
                ...room,
                boardingHouseId: savedHouse._id,
            }));
            // B·ªè { session }
            await Room.insertMany(roomDocs);
        }

        res.status(201).json({ message: "Nh√† tr·ªç v√† c√°c ph√≤ng ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!", data: savedHouse });

    } catch (err) {
        console.error("[CREATE BOARDING HOUSE ERROR]", err);
        res.status(500).json({ message: "L·ªói m√°y ch·ªß khi t·∫°o nh√† tr·ªç." });
    }
};

/**
 * @description C·∫≠p nh·∫≠t th√¥ng tin c∆° b·∫£n c·ªßa m·ªôt nh√† tr·ªç.
 * @route PUT /api/boarding-houses/:id
 */
exports.updateBoardingHouse = async (req, res) => {
    try {
        const { id } = req.params;
        const { name, description, amenities } = req.body;
        const location = JSON.parse(req.body.location || "{}");
        const photoPaths = req.files?.map((file) => `/uploads/accommodation/${file.filename}`) || [];

        // 1. L·∫•y th√¥ng tin nh√† tr·ªç hi·ªán t·∫°i TR∆Ø·ªöC KHI c·∫≠p nh·∫≠t
        const existingHouse = await BoardingHouse.findById(id);
        if (!existingHouse) {
            // D·ªçn d·∫πp file ƒë√£ t·∫£i l√™n n·∫øu kh√¥ng t√¨m th·∫•y nh√† tr·ªç
            if (req.files) {
                const cleanupPromises = req.files.map(file => fs.unlink(file.path).catch(e => console.error("L·ªói khi d·ªçn d·∫πp file:", e)));
                await Promise.all(cleanupPromises);
            }
            return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y nh√† tr·ªç" });
        }
        
        // L∆∞u l·∫°i danh s√°ch ·∫£nh c≈© ƒë·ªÉ x·ª≠ l√Ω sau
        const oldPhotos = existingHouse.photos || [];

        const updateData = {
            name,
            description,
            amenities,
            location,
            updatedAt: Date.now(),
            approvedStatus: "pending"
        };

        // 2. Ch·ªâ ghi ƒë√® 'photos' n·∫øu c√≥ ·∫£nh m·ªõi ƒë∆∞·ª£c t·∫£i l√™n
        if (photoPaths.length > 0) {
            updateData.photos = photoPaths;
        }

        const updated = await BoardingHouse.findByIdAndUpdate(id, updateData, { new: true });

        // 3. N·∫øu c·∫≠p nh·∫≠t DB th√†nh c√¥ng V√Ä c√≥ ·∫£nh m·ªõi, h√£y x√≥a ·∫£nh c≈©
        if (updated && photoPaths.length > 0 && oldPhotos.length > 0) {
            const deletePromises = oldPhotos.map(photoUrl => {
                const filename = path.basename(photoUrl);
                const filePathToDelete = path.join(process.cwd(), 'public', 'uploads', 'accommodation', filename);
                
                // Tr·∫£ v·ªÅ m·ªôt promise ƒë·ªÉ x√≥a file
                return fs.unlink(filePathToDelete).catch(err => {
                    // N·∫øu l·ªói l√† 'ENOENT' (file kh√¥ng t·ªìn t·∫°i), ta b·ªè qua
                    if (err.code === 'ENOENT') {
                        console.log(`File kh√¥ng t·ªìn t·∫°i, b·ªè qua vi·ªác x√≥a: ${filePathToDelete}`);
                        return; 
                    }
                    // N·∫øu l√† l·ªói kh√°c, log l·∫°i ƒë·ªÉ debug
                    console.error(`L·ªói th·ª±c s·ª± khi x√≥a file ${filePathToDelete}:`, err);
                });
            });

            // ƒê·ª£i t·∫•t c·∫£ c√°c t√°c v·ª• x√≥a ho√†n th√†nh
            await Promise.all(deletePromises);
        }

        res.status(200).json({ message: "C·∫≠p nh·∫≠t nh√† tr·ªç th√†nh c√¥ng", data: updated });

    } catch (err) {
        console.error("[UPDATE BOARDING HOUSE ERROR]", err);
        // D·ªçn d·∫πp file m·ªõi t·∫£i l√™n n·∫øu c√≥ l·ªói x·∫£y ra sau khi upload
        if (req.files) {
            const cleanupPromises = req.files.map(file => fs.unlink(file.path).catch(e => console.error("L·ªói khi d·ªçn d·∫πp file:", e)));
            await Promise.all(cleanupPromises);
        }
        res.status(500).json({ message: "Server error" });
    }
};

/**
 * @description L·∫•y danh s√°ch t·∫•t c·∫£ nh√† tr·ªç (c√≥ t√≥m t·∫Øt th√¥ng tin ph√≤ng).
 * @route GET /api/boarding-houses
 */
exports.getAllBoardingHouses = async (req, res) => {
    try {
        const { ownerId } = req.query;
        const matchFilter = {};
        if (ownerId) {
            matchFilter.ownerId = new mongoose.Types.ObjectId(ownerId);
        } else {
            matchFilter.approvedStatus = "approved";
        }

        const boardingHouses = await BoardingHouse.aggregate([
            { $match: matchFilter },
            { $lookup: { from: 'rooms', localField: '_id', foreignField: 'boardingHouseId', as: 'rooms' } },
            {
                $addFields: {
                    availableRoomsCount: { $size: { $filter: { input: '$rooms', as: 'room', cond: { $eq: ['$$room.status', 'Available'] } } } },
                    minPrice: { $min: '$rooms.price' },
                    maxPrice: { $max: '$rooms.price' },
                    totalRooms: { $size: '$rooms' }
                }
            },
            { $project: { rooms: 0 } }
        ]);

        await BoardingHouse.populate(boardingHouses, { path: 'ownerId', select: 'name email' });
        res.status(200).json(boardingHouses);
    } catch (err) {
        console.error("[GET ALL BOARDING HOUSES ERROR]", err);
        res.status(500).json({ message: "Server error" });
    }
};

/**
 * @description L·∫•y chi ti·∫øt m·ªôt nh√† tr·ªç, k√®m danh s√°ch ph√≤ng v√† ƒë√°nh gi√°.
 * @route GET /api/boarding-houses/:id
 */
exports.getBoardingHouseById = async (req, res) => {
  try {
    const house = await BoardingHouse.findById(req.params.id).populate(
      "ownerId",
      "name email phone"
    );
    if (!house)
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y nh√† tr·ªç" });

    // L·∫•y danh s√°ch ph√≤ng
    const rooms = await Room.find({ boardingHouseId: house._id });

    // üî• G·∫Øn th√™m tr·∫°ng th√°i booking cho m·ªói ph√≤ng
    const roomsWithStatus = await Promise.all(
      rooms.map(async (room) => {
        const latestBooking = await Booking.findOne({ roomId: room._id })
          .sort({ createdAt: -1 })
          .lean();

        let bookingStatus = "Available"; // m·∫∑c ƒë·ªãnh

        if (latestBooking) {
          if (
            latestBooking.status === "paid" &&
            latestBooking.contractStatus === "approved"
          ) {
            bookingStatus = "Paid"; // ‚úÖ ƒë√£ thanh to√°n & ƒë∆∞·ª£c duy·ªát
          } else if (
            latestBooking.status === "pending" ||
            latestBooking.contractStatus === "pending"
          ) {
            bookingStatus = "Pending"; // üïì ch·ªù thanh to√°n ho·∫∑c ch·ªù duy·ªát
          }
        }

        return {
          ...room.toObject(),
          bookingStatus,
        };
      })
    );

    const reviews = await Review.find({
      boardingHouseId: req.params.id,
    })
      .populate("customerId", "name avatar")
      .sort({ createdAt: -1 });

    const result = { ...house.toObject(), rooms: roomsWithStatus, reviews };
    res.status(200).json(result);
  } catch (err) {
    console.error("[GET BOARDING HOUSE BY ID ERROR]", err);
    res.status(500).json({ message: "Server error" });
  }
};

/**
 * @description X√≥a m·ªôt nh√† tr·ªç v√† t·∫•t c·∫£ c√°c ph√≤ng, ƒë√°nh gi√° li√™n quan.
 * @route DELETE /api/boarding-houses/:id
 */
exports.deleteBoardingHouse = async (req, res) => {
    const session = await mongoose.startSession();
    session.startTransaction();
    try {
        const houseId = req.params.id;

        const bookedRoom = await Room.findOne({ boardingHouseId: houseId, status: "Booked" });
        if (bookedRoom) {
            await session.abortTransaction();
            return res.status(400).json({ message: "Kh√¥ng th·ªÉ x√≥a nh√† tr·ªç n√†y v√¨ ƒëang c√≥ ph√≤ng ƒë∆∞·ª£c kh√°ch h√†ng ƒë·∫∑t!" });
        }

        await Review.deleteMany({ boardingHouseId: houseId }, { session });
        await Room.deleteMany({ boardingHouseId: houseId }, { session });
        const deletedHouse = await BoardingHouse.findByIdAndDelete(houseId, { session });
        if (!deletedHouse) throw new Error("Kh√¥ng t√¨m th·∫•y nh√† tr·ªç ƒë·ªÉ x√≥a.");

        await session.commitTransaction();
        res.status(200).json({ message: "X√≥a nh√† tr·ªç v√† t·∫•t c·∫£ c√°c ph√≤ng th√†nh c√¥ng" });
    } catch (err) {
        await session.abortTransaction();
        console.error("[DELETE BOARDING HOUSE ERROR]", err);
        res.status(500).json({ message: "Server error" });
    } finally {
        session.endSession();
    }
};

// ================================================================
// SECTION: QU·∫¢N L√ù ƒê√ÅNH GI√Å (REVIEW)
// ================================================================

/**
 * @description G·ª≠i m·ªôt ƒë√°nh gi√° m·ªõi cho nh√† tr·ªç.
 * @route POST /api/boarding-houses/:id/reviews
 */
exports.submitReview = async (req, res) => {
    try {
        const boardingHouseId = req.params.id;
        const { rating, comment, purpose } = req.body;
        const userId = req.user.id;

        const house = await BoardingHouse.findById(boardingHouseId);
        if (!house) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y nh√† tr·ªç" });

        const roomIds = (await Room.find({ boardingHouseId }).select('_id')).map(r => r._id);
        const userBooking = await Booking.findOne({
  userId,
  boardingHouseId,
  contractStatus: { $in: ['paid', 'approved'] }
});

        if (!userBooking) return res.status(403).json({ message: "B·∫°n ch·ªâ c√≥ th·ªÉ ƒë√°nh gi√° nh√† tr·ªç m√† b·∫°n ƒë√£ ƒë·∫∑t ph√≤ng." });

        const existingReview = await Review.findOne({ boardingHouseId, customerId: userId });
        if (existingReview) return res.status(400).json({ message: "B·∫°n ƒë√£ ƒë√°nh gi√° nh√† tr·ªç n√†y r·ªìi." });

        const newReview = new Review({ boardingHouseId, customerId: userId, user: userId, rating, comment, purpose });
        await newReview.save();
        const populatedReview = await Review.findById(newReview._id).populate('customerId', 'name avatar');
        res.status(201).json({ review: populatedReview });
    } catch (error) {
        console.error("Error submitting review:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};

exports.getReviews = async (req, res) => {
    try {
        const { id } = req.params;
        const reviews = await Review.find({ boardingHouseId: id }).populate('user', 'name avatar');
        res.status(200).json({ reviews });
    } catch (error) {
        console.error("Error getting reviews:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};

// S·ª≠a review
exports.editReview = async (req, res) => {
    try {
        const { reviewId } = req.params;
        const { rating, comment, purpose } = req.body;

        if (!rating || !comment || !purpose) {
            return res.status(400).json({ message: "All fields are required." });
        }

        const review = await Review.findById(reviewId);
        if (!review) {
            return res.status(404).json({ message: "Review not found" });
        }

        // Ch·ªâ cho ph√©p user ƒë√£ t·∫°o review ƒë∆∞·ª£c s·ª≠a
        if (String(review.user) !== String(req.user.id)) {
            return res.status(403).json({ message: "Not authorized to edit this review" });
        }

        review.rating = rating;
        review.comment = comment;
        review.purpose = purpose;
        await review.save();

        res.status(200).json({ review });
    } catch (error) {
        console.error("Error editing review:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};

// X√≥a review
exports.deleteReview = async (req, res) => {
    try {
        const { reviewId } = req.params;

        const review = await Review.findById(reviewId);
        if (!review) {
            return res.status(404).json({ message: "Review not found" });
        }

        // Ch·ªâ cho ph√©p user ƒë√£ t·∫°o review ƒë∆∞·ª£c x√≥a
        if (String(review.user) !== String(req.user.id)) {
            return res.status(403).json({ message: "Not authorized to delete this review" });
        }

        await review.deleteOne();

        res.status(200).json({ message: "Review deleted successfully" });
    } catch (error) {
        console.error("Error deleting review:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};

// ================================================================
// SECTION: TH·ªêNG K√ä CHO CH·ª¶ TR·ªå (OWNER)
// ================================================================

// H√†m helper ƒë·ªÉ l·∫•y ID nh√† v√† ph√≤ng c·ªßa owner
const getOwnerProperties = async (ownerId) => {
    const houses = await BoardingHouse.find({ ownerId }).select('_id');
    const houseIds = houses.map(h => h._id);
    const rooms = await Room.find({ boardingHouseId: { $in: houseIds } }).select('_id');
    const roomIds = rooms.map(r => r._id);
    return { houses, houseIds, rooms, roomIds };
};


/**
 * @description L·∫•y th·ªëng k√™ t·ªïng quan cho ch·ªß tr·ªç.
 * @route GET /api/owner/statistics
 */
exports.getOwnerStatistics = async (req, res) => {
  try {
    const ownerId = req.user.id;

    // üîπ 1. L·∫•y to√†n b·ªô BoardingHouse c·ªßa owner
    const houses = await BoardingHouse.find({ ownerId }).select("_id approvedStatus");
    const houseIds = houses.map(h => h._id);

    const totalHouses = houses.length;
    const approvedHouses = houses.filter(h => h.approvedStatus === "approved").length;
    const pendingHouses = houses.filter(h => h.approvedStatus === "pending").length;
    const rejectedHouses = houses.filter(h => h.approvedStatus === "rejected").length;

    // üîπ N·∫øu ch∆∞a c√≥ nh√† tr·ªç n√†o => return s·ªõm
    if (houseIds.length === 0) {
      return res.status(200).json({
        success: true,
        statistics: {
          totalHouses,
          approvedHouses,
          pendingHouses,
          rejectedHouses,
          totalBookings: 0,
          totalRevenue: 0,
        },
      });
    }

    // üîπ 2. L·∫•y t·∫•t c·∫£ booking c·ªßa c√°c nh√† tr·ªç ƒë√≥
    const bookings = await Booking.find({
      boardingHouseId: { $in: houseIds },
    })
      .populate("roomId", "price") // ƒë·ªÉ l·∫•y gi√° t·ª´ Room
      .select("contractStatus roomId");

    // üîπ 3. Chu·∫©n h√≥a contractStatus v·ªÅ ch·ªØ th∆∞·ªùng
    const normalizeStatus = (status) => (status || "").toLowerCase();

    // üîπ 4. L·ªçc booking c√≥ status l√† 'paid' ho·∫∑c 'approved'
    const relevantBookings = bookings.filter((b) =>
      ["Paid", "approved"].includes(normalizeStatus(b.contractStatus))
    );

    // üîπ 5. T√≠nh t·ªïng s·ªë booking v√† t·ªïng doanh thu
    const totalBookings = relevantBookings.length;
    const totalRevenue = relevantBookings.reduce(
      (sum, b) => sum + (b.roomId?.price || 0),
      0
    );

    // üîπ 6. Tr·∫£ v·ªÅ k·∫øt qu·∫£
    return res.status(200).json({
      success: true,
      statistics: {
        totalHouses,
        approvedHouses,
        pendingHouses,
        rejectedHouses,
        totalBookings,
        totalRevenue,
      },
    });
  } catch (error) {
    console.error("Error getting owner statistics:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};



/**
 * @description L·∫•y danh s√°ch c√°c nh√† tr·ªç c·ªßa owner k√®m rating trung b√¨nh.
 * @route GET /api/owner/boarding-houses/ratings
 */
exports.getOwnerBoardingHousesWithRatings = async (req, res) => {
    try {
        const ownerId = req.user.id;
        const houses = await BoardingHouse.find({ ownerId, approvedStatus: "approved" }).select('_id name createdAt');

        const housesWithRatings = await Promise.all(
            houses.map(async (house) => {
                const reviews = await Review.find({ boardingHouseId: house._id });
                let avgRating = 0;
                if (reviews.length > 0) {
                    const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
                    avgRating = (totalRating / reviews.length).toFixed(1);
                }
                return {
                    _id: house._id,
                    name: house.name,
                    averageRating: parseFloat(avgRating),
                    totalReviews: reviews.length,
                    createdAt: house.createdAt
                };
            })
        );
        res.status(200).json({ success: true, boardingHouses: housesWithRatings });
    } catch (error) {
        console.error("Error getting owner houses with ratings:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};


/**
 * @description L·∫•y chi ti·∫øt ratings c·ªßa 1 nh√† tr·ªç cho owner.
 * @route GET /api/boarding-houses/owner/:id/ratings
 * @access Owner
 */
exports.getBoardingHouseRatingsForOwner = async (req, res) => {
    try {
        const boardingHouseId = req.params.id;
        const ownerId = req.user.id;

        // Ki·ªÉm tra nh√† tr·ªç c√≥ t·ªìn t·∫°i v√† thu·ªôc v·ªÅ owner kh√¥ng
        const boardingHouse = await BoardingHouse.findOne({
            _id: boardingHouseId,
            ownerId: ownerId
        });

        if (!boardingHouse) {
            return res.status(404).json({
                success: false,
                message: "Kh√¥ng t√¨m th·∫•y nh√† tr·ªç ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p."
            });
        }

        // L·∫•y t·∫•t c·∫£ reviews cho nh√† tr·ªç n√†y
        const reviews = await Review.find({ boardingHouseId: boardingHouseId })
            .populate('customerId', 'name email avatar')
            .sort({ createdAt: -1 });

        // T√≠nh rating trung b√¨nh
        let avgRating = 0;
        if (reviews.length > 0) {
            const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
            avgRating = (totalRating / reviews.length).toFixed(1);
        }

        res.status(200).json({
            success: true,
            accommodationTitle: boardingHouse.name,
            ratings: reviews,
            avgRating: parseFloat(avgRating),
            totalReviews: reviews.length
        });
    } catch (error) {
        console.error("Error getting accommodation ratings:", error);
        res.status(500).json({ success: false, message: "Internal server error" });
    }
};

/**
 * @description L·∫•y c√°c ƒë·∫∑t ph√≤ng g·∫ßn ƒë√¢y cho ch·ªß tr·ªç.
 * @route GET /api/owner/bookings/recent
 */
exports.getOwnerRecentBookings = async (req, res) => {
  try {
    const ownerId = req.user.id;
    const { limit = 10 } = req.query;

    // üîπ T√¨m t·∫•t c·∫£ nh√† tr·ªç thu·ªôc ch·ªß s·ªü h·ªØu
    const houses = await BoardingHouse.find({ ownerId }).select("_id");
    const houseIds = houses.map(h => h._id);

    if (houseIds.length === 0) {
      return res.status(200).json({ success: true, bookings: [] });
    }

    // üîπ T√¨m t·∫•t c·∫£ bookings thu·ªôc c√°c nh√† tr·ªç ƒë√≥
    const bookings = await Booking.find({ boardingHouseId: { $in: houseIds } })
      .sort({ createdAt: -1 })
      .limit(Number(limit))
      .populate("userId", "name email")
      .populate("boardingHouseId", "name photos location price")
      .populate("roomId", "price roomNumber"); // ‚úÖ l·∫•y gi√° v√† s·ªë ph√≤ng

    // üîπ Tr·∫£ d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c format
    res.status(200).json({
      success: true,
      bookings: bookings.map(b => ({
        _id: b._id,
        customerName: b.userId?.name,
        houseName: b.boardingHouseId?.name,
         houseId: b.boardingHouseId?._id,       
    housePhotos: b.boardingHouseId?.photos, 
        roomNumber: b.roomId?.roomNumber || "N/A",
        amount: b.roomId?.price || 0,
        status: b.status || b.contractStatus, 
        createdAt: b.createdAt
      }))
    });
  } catch (error) {
    console.error("Error getting recent bookings:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};




/**
 * @description L·∫•y c√°c nh√† tr·ªç h√†ng ƒë·∫ßu c·ªßa owner (d·ª±a tr√™n s·ªë l∆∞·ª£t ƒë·∫∑t).
 * @route GET /api/owner/boarding-houses/top
 */
exports.getOwnerTopBoardingHouses = async (req, res) => {
  try {
    const ownerId = req.user.id;
    const { limit = 5 } = req.query;

    const houses = await BoardingHouse.find({ ownerId, approvedStatus: "approved" }).select("_id name");

    const housesWithRatings = await Promise.all(
      houses.map(async (house) => {
        const reviews = await Review.find({ boardingHouseId: house._id });
        const avgRating =
          reviews.length > 0
            ? (reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length).toFixed(1)
            : 0;
        return { _id: house._id, name: house.name, averageRating: parseFloat(avgRating), totalReviews: reviews.length };
      })
    );

    const sorted = housesWithRatings.sort((a, b) => b.averageRating - a.averageRating);
    res.status(200).json({ success: true, accommodations: sorted.slice(0, limit) });
  } catch (error) {
    console.error("Error getting top boarding houses:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};


/**
 * @description L·∫•y th√¥ng tin g√≥i th√†nh vi√™n hi·ªán t·∫°i v√† s·ªë b√†i ƒëƒÉng.
 * @route GET /api/owner/membership-info
 */
exports.getOwnerMembershipInfo = async (req, res) => {
  try {
    const ownerId = req.user.id;

    // üîπ L·∫•y membership m·ªõi nh·∫•t c·ªßa owner
    const latestMembership = await Membership.findOne({ ownerId })
      .sort({ endDate: -1 })
      .populate("packageId");

    // üîπ N·∫øu ch∆∞a t·ª´ng mua g√≥i ho·∫∑c kh√¥ng c√≥ package h·ª£p l·ªá
    if (!latestMembership || !latestMembership.packageId) {
      return res.status(200).json({
        success: true,
        membershipInfo: { hasActiveMembership: false },
      });
    }

    const packageInfo = latestMembership.packageId;

    // üîπ Ki·ªÉm tra h·∫øt h·∫°n
    const isExpired = new Date() > new Date(latestMembership.endDate);

    // üîπ ƒê·∫øm s·ªë l∆∞·ª£ng nh√† tr·ªç hi·ªán c√≥ c·ªßa owner
    const currentPostsCount = await BoardingHouse.countDocuments({ ownerId });

    const postsAllowed = packageInfo.postsAllowed || 0;

    // üîπ Tr·∫£ v·ªÅ k·∫øt qu·∫£
    res.status(200).json({
      success: true,
      membershipInfo: {
        hasActiveMembership: latestMembership.status === "Active" && !isExpired,
        packageName: packageInfo.packageName,
        type: latestMembership.type,
        price: latestMembership.price,
        postsAllowed,
        currentPostsCount,
        remainingPosts: Math.max(0, postsAllowed - currentPostsCount),
        isExpired,
        startDate: latestMembership.startDate,
        expiredAt: latestMembership.endDate,
        status: latestMembership.status,
      },
    });
  } catch (error) {
    console.error("Error getting owner membership info:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};

/**
 * @description L·∫•y doanh thu h√†ng th√°ng c·ªßa owner.
 * @route GET /api/owner/revenue/monthly
 */
exports.getOwnerMonthlyRevenue = async (req, res) => {
  try {
    const ownerId = req.user.id;
    const { months = 6 } = req.query;

    // üîπ L·∫•y t·∫•t c·∫£ nh√† tr·ªç thu·ªôc owner
    const houses = await BoardingHouse.find({ ownerId }).select("_id");
    const houseIds = houses.map(h => h._id);

    if (houseIds.length === 0) {
      return res.status(200).json({ success: true, monthlyRevenue: [] });
    }

    const monthlyData = [];

    for (let i = months - 1; i >= 0; i--) {
      const targetDate = new Date();
      targetDate.setMonth(targetDate.getMonth() - i);

      // T√≠nh kho·∫£ng th·ªùi gian ƒë·∫ßu v√† cu·ªëi th√°ng
      const start = new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
      const end = new Date(targetDate.getFullYear(), targetDate.getMonth() + 1, 0, 23, 59, 59, 999);

      // üîπ L·∫•y t·∫•t c·∫£ booking thu·ªôc c√°c nh√† tr·ªç n√†y
      const bookings = await Booking.find({
        boardingHouseId: { $in: houseIds },
        status: { $in: ["Paid", "completed"] }, // c√°c tr·∫°ng th√°i ƒë√£ thanh to√°n
        createdAt: { $gte: start, $lte: end },
      }).populate("roomId", "price");

      // üîπ T√≠nh doanh thu t·ª´ c√°c booking
      const revenue = bookings.reduce((sum, b) => sum + (b.roomId?.price || 0), 0);

      monthlyData.push({
        month: targetDate.toLocaleString("vi-VN", { month: "short", year: "numeric" }),
        revenue,
        bookingsCount: bookings.length,
        monthNumber: targetDate.getMonth() + 1,
        year: targetDate.getFullYear(),
      });
    }

    res.status(200).json({ success: true, monthlyRevenue: monthlyData });
  } catch (error) {
    console.error("Error getting monthly revenue:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};


// Get Owner Membership Info with Boardinghouse Count
exports.getOwnerMembershipInfo = async (req, res) => {
    try {
        const ownerId = req.user.id;

        // L·∫•y membership hi·ªán t·∫°i
        const latestPayment = await Payment.findOne({
            ownerId,
            status: "Paid",
        })
            .sort({ createAt: -1 })
            .populate("membershipPackageId");

        if (!latestPayment || !latestPayment.membershipPackageId) {
            return res.status(200).json({
                success: true,
                membershipInfo: {
                    hasActiveMembership: false,
                    packageName: "No Active Membership",
                    postsAllowed: 0,
                    currentPostsCount: 0,
                    remainingPosts: 0,
                    isExpired: true
                }
            });
        }

        const membershipPackage = latestPayment.membershipPackageId;
        const durationDays = membershipPackage.duration || 0;
        const createdAt = latestPayment.createdAt;
        const expiredAt = new Date(
            createdAt.getTime() + durationDays * 24 * 60 * 60 * 1000
        );

        const isExpired = new Date() > expiredAt;

        // ƒê·∫øm s·ªë boarding houses hi·ªán t·∫°i
        const currentPostsCount = await BoardingHouse.countDocuments({
            ownerId
        });

        const postsAllowed = membershipPackage.postsAllowed || 0;
        const remainingPosts = Math.max(0, postsAllowed - currentPostsCount);

        res.status(200).json({
            success: true,
            membershipInfo: {
                hasActiveMembership: !isExpired,
                packageName: membershipPackage.packageName || membershipPackage.name,
                postsAllowed,
                currentPostsCount,
                remainingPosts,
                isExpired,
                expiredAt,
                purchaseDate: createdAt
            }
        });
    } catch (error) {
        console.error("Error getting owner membership info:", error);
        res.status(500).json({
            success: false,
            message: "Internal server error"
        });
    }
};


/**
 * @description L·∫•y c√°c nh√† tr·ªç h√†ng ƒë·∫ßu c·ªßa owner (d·ª±a tr√™n s·ªë l∆∞·ª£t ƒë·∫∑t).
 * @route GET /api/boarding-houses/owner/top-accommodations
 * @access Owner
 */
exports.getOwnerTopAccommodations = async (req, res) => {
    try {
        const ownerId = req.user.id;
        const limit = parseInt(req.query.limit) || 5;

        // L·∫•y t·∫•t c·∫£ nh√† tr·ªç c·ªßa owner
        const ownerHouses = await BoardingHouse.find({ ownerId }).select('_id name');

        // T√≠nh to√°n th·ªëng k√™ cho t·ª´ng nh√† tr·ªç
        const houseStats = await Promise.all(
            ownerHouses.map(async (house) => {
                // L·∫•y t·∫•t c·∫£ c√°c ph√≤ng thu·ªôc nh√† tr·ªç n√†y
                const roomsInHouse = await Room.find({ boardingHouseId: house._id }).select('_id');
                const roomIdsInHouse = roomsInHouse.map(r => r._id);

                // ƒê·∫øm s·ªë l∆∞·ª£ng booking c·ªßa c√°c ph√≤ng n√†y
                const bookingCount = await Booking.countDocuments({
                    propertyId: { $in: roomIdsInHouse },
                    status: { $in: ['paid', 'completed'] }
                });

                // T√≠nh rating trung b√¨nh
                const reviews = await Review.find({ boardingHouseId: house._id });
                let avgRating = 0;
                if (reviews.length > 0) {
                    const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
                    avgRating = (totalRating / reviews.length);
                }

                return {
                    key: house._id,
                    title: house.name, // ƒê·ªïi t·ª´ title sang name
                    bookings: bookingCount,
                    rating: parseFloat(avgRating.toFixed(1))
                };
            })
        );

        // S·∫Øp x·∫øp theo s·ªë booking gi·∫£m d·∫ßn v√† l·∫•y top
        const topAccommodations = houseStats
            .sort((a, b) => b.bookings - a.bookings)
            .slice(0, limit);

        res.status(200).json({
            success: true,
            accommodations: topAccommodations
        });
    } catch (error) {
        console.error("Error getting owner top accommodations:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};


/**
 * @description L·∫•y th√¥ng tin g√≥i th√†nh vi√™n hi·ªán t·∫°i c·ªßa owner.
 * @route GET /api/boarding-houses/owner/current-membership
 * @access Owner
 */
exports.getOwnerCurrentMembership = async (req, res) => {
  try {
    const ownerId = req.user.id;

    const currentMembership = await Membership.findOne({
      ownerId,
      status: { $in: ["Active", "Pending"] }
    })
      .sort({ endDate: -1 })
      .populate("packageId");

    if (!currentMembership) {
      return res.status(200).json({
        success: true,
        membership: {
          packageName: "No Active Membership",
          isActive: false,
          expiredAt: null,
        },
      });
    }

    const isExpired = new Date() > new Date(currentMembership.endDate);

    res.status(200).json({
      success: true,
      membership: {
        packageName: currentMembership.packageId?.packageName || "Unknown Package",
        isActive: !isExpired,
        expiredAt: currentMembership.endDate,
        startDate: currentMembership.startDate,
        status: currentMembership.status,
      },
    });
  } catch (error) {
    console.error("Error getting current membership:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};
